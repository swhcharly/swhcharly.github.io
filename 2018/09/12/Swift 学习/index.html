<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8 no-js"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9 no-js"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en">
<!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <meta name="description" content="Swift 学习： [toc] 函数：1. 可元数组：   函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配 1234567891011121314151617181920212223242526// 函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配// func calculateStatistics(_ scores: [Int]) -&amp;gt; (min">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2018/09/12/Swift 学习/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Swift 学习： [toc] 函数：1. 可元数组：   函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配 1234567891011121314151617181920212223242526// 函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配// func calculateStatistics(_ scores: [Int]) -&amp;gt; (min">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-09-12T09:02:11.376Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Swift 学习： [toc] 函数：1. 可元数组：   函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配 1234567891011121314151617181920212223242526// 函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配// func calculateStatistics(_ scores: [Int]) -&amp;gt; (min">
  
  
    
  <meta content="{{ title }}" name="description">
  <meta content="{{ title }}" name="keywords">
  <meta content="{{ title }}" name="author">

  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|PT+Sans+Narrow|Source+Sans+Pro:200,300,400,600,700,900&amp;subset=all" rel="stylesheet" type="text/css">

  <!-- Global styles START -->   
  <link rel="stylesheet" href="/metronic/assets/plugins/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/bootstrap/css/bootstrap.min.css">
  <!-- Global styles END --> 
   
  <!-- Page level plugin styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/animate.css">
  <link rel="stylesheet" href="/metronic/assets/plugins/owl.carousel/assets/owl.carousel.css">
  <!-- Page level plugin styles END -->

  <!-- Theme styles START -->
  <link rel="stylesheet" href="/metronic/assets/pages/css/components.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/slider.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style.css">
  <link rel="stylesheet" href="/metronic/assets/pages/css/portfolio.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/style-responsive.css">
  <link rel="stylesheet" href="/metronic/assets/corporate/css/themes/undefined.css">
  <link rel="stylesheet" href="/css/theme-styles.css">
  <!-- Theme styles END -->
</head>

<body class="corporate">
  <!-- BEGIN TOP BAR -->
<div class="pre-header">
  <div class="container">
    <div class="row">
      <!-- BEGIN TOP BAR LEFT PART -->
      <div class="col-md-6 col-sm-6 col-xs-9 additional-shop-info">
	<ul class="list-unstyled list-inline">
	  <li><i class="fa fa-phone"></i><span></span></li>
	  <li><i class="fa fa-envelope-o"></i><span></span></li>
	</ul>
      </div>
      <!-- END TOP BAR LEFT PART -->
      <!-- BEGIN TOP BAR MENU -->
      <div class="col-md-6 col-sm-6 col-xs-3 additional-nav">
	<ul class="list-unstyled list-inline pull-right">
	  <li><a href="/login">Log In</a></li>
	</ul>
      </div>
      <!-- END TOP BAR MENU -->
    </div>
  </div>        
</div>
<!-- END TOP BAR -->
<!-- BEGIN HEADER -->
<div class="header">
  <div class="container">
    <!--<a class="site-logo" href="/" id="logo">Hexo</a>-->

    <a class="site-logo" href="/">
      <img src="/metronic/assets/corporate/img/logos/logo-corp-undefined.png" alt="Metronic FrontEnd">
    </a>

    <a href="javascript:void(0);" class="mobi-toggler"><i class="fa fa-bars"></i></a>

    <!-- BEGIN NAVIGATION -->
    <div class="header-navigation pull-right font-transform-inherit">
      <ul>
	
	<!-- BEGIN TOP SEARCH -->
	<li class="menu-search">
	  <span class="sep"></span>
	  <i class="fa fa-search search-btn"></i>
	  <div class="search-box">
	    <form action="#">
	      <div class="input-group">
		<input type="text" placeholder="Search" class="form-control st-default-search-input">
		<span class="input-group-btn">
		  <button class="btn btn-primary" type="submit">Search</button>
		</span>
	      </div>
	    </form>
	  </div> 
	</li>
	<!-- END TOP SEARCH -->
      </ul>
    </div>
    <!-- END NAVIGATION -->
  </div>
</div>
<!-- Header END -->

  <div class="container">
  <ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/archives/">Blog</a></li>
    <li class="active">Post</li>
  </ul>
  <section id="main">
    

    <div class="row">
<div class="col-md-9 col-sm-9 blog-posts">
<article id="post-Swift 学习" class="article article-type-post blog-item" itemscope itemprop="blogPost">
  <div class="article-meta">
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Swift 学习：</p>
<p>[toc]</p>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><h4 id="1-可元数组："><a href="#1-可元数组：" class="headerlink" title="1. 可元数组："></a>1. 可元数组：</h4><p>   函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 函数返回值可以是一个组合（元组），返回值类型与函数体返回值类型强匹配</span><br><span class="line">// </span><br><span class="line">func calculateStatistics(_ scores: [Int]) -&gt; (min: Double, max: Double, sum: Double, mean: Int)? &#123;</span><br><span class="line">    </span><br><span class="line">    if scores.isEmpty &#123; return nil &#125;</span><br><span class="line"></span><br><span class="line">    var min = Double(scores[0])</span><br><span class="line">    var max = Double(scores[0])</span><br><span class="line">    var sum = Double(0)</span><br><span class="line">    var mean = 0</span><br><span class="line">    </span><br><span class="line">    for score in scores &#123;</span><br><span class="line">        let score_temp = Double(score)</span><br><span class="line">        </span><br><span class="line">        if score_temp &gt; max &#123;</span><br><span class="line">            max = score_temp</span><br><span class="line">        &#125; else if score_temp &lt; min &#123;</span><br><span class="line">            min = score_temp</span><br><span class="line">        &#125;</span><br><span class="line">        sum += score_temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mean = Int(sum)/scores.count</span><br><span class="line">    </span><br><span class="line">    return (min, max, sum, mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   通过 if 判断返回元组是否为 nil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过 if 判断返回元祖是否为 nil</span><br><span class="line">if let statistics = calculateStatistics([5, 3, 100, 3, 9])&#123;</span><br><span class="line"></span><br><span class="line">    print(statistics.sum)</span><br><span class="line">    print(statistics)</span><br><span class="line"></span><br><span class="line">    print(Double(statistics.3))</span><br><span class="line">    print(statistics.mean)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//print(statistics.sum)</span><br><span class="line">//</span><br><span class="line">//print(Double(statistics.3))</span><br><span class="line">//print(statistics.mean)</span><br><span class="line"></span><br><span class="line">if let statistics1 = calculateStatistics([])&#123;</span><br><span class="line">    print(statistics1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-参数标签"><a href="#2-参数标签" class="headerlink" title="2.参数标签:"></a>2.参数标签:</h4><p>  默认参数标签与参数名称一样；</p>
<p>  忽略参数标签 _</p>
<p>  如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//忽略参数标签，默认参数标签，参数标签</span><br><span class="line">func myFunction (_ first :String, Second:Int, three Three:Bool, three Four: Double)&#123;</span><br><span class="line">    print(first + String(Second) + String(Three) + String(Four))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction(&quot;first&quot;, Second: 2, three: false, three: 2.0)</span><br></pre></td></tr></table></figure>
<h4 id="3-可变参数："><a href="#3-可变参数：" class="headerlink" title="3.可变参数："></a>3.可变参数：</h4><p>一个可变参数（variadic parameter）可以接受零个或多个值。</p>
<p>通过在变量类型名后面加入（…）的方式来定义可变参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">    var total: Double = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total / Double(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure>
<h4 id="4-输入输出参数"><a href="#4-输入输出参数" class="headerlink" title="4.输入输出参数:"></a>4.输入输出参数:</h4><p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。</p>
<p>定义一个输入输出参数时，在参数定义前加 inout 关键字。</p>
<p>当传入的参数作为输入输出参数时，需要在参数名前加 &amp; 符，表示这个值可以被函数修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//inout</span><br><span class="line">func swapTwoInts(_ a: inout Int, _ b: inout Int)&#123;</span><br><span class="line">    let temA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 3</span><br><span class="line">var b = 5</span><br><span class="line">print(a,b)</span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure>
<h4 id="5-函数类型"><a href="#5-函数类型" class="headerlink" title="5.函数类型:"></a>5.函数类型:</h4><p>每个函数都有种特定的函数类型，函数的类型由函数的参数类型和返回类型组成。</p>
<p>函数类型作为参数类型</p>
<p>函数类型作为返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//函数类型作为参数</span><br><span class="line">func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mathFunction: (Int, Int) -&gt; Int = addTwoInts</span><br><span class="line"></span><br><span class="line">func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123;</span><br><span class="line">    print(&quot;Result: \(mathFunction(a, b))&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func numFirst(_ a:Int)-&gt;Int&#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMathResult(addTwoInts, numFirst(6), 5)</span><br><span class="line"></span><br><span class="line">//函数类型作为返回值</span><br><span class="line">func stepForward(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    return input + 1</span><br><span class="line">&#125;</span><br><span class="line">func stepBackward(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    return input - 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    return backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var currentValue = 10</span><br><span class="line">let moveNearerToZero = chooseStepFunction(backward: currentValue &gt;= 0)</span><br><span class="line"></span><br><span class="line">// Counting to zero:</span><br><span class="line">while currentValue &gt;= 0 &#123;</span><br><span class="line">    print(&quot;\(currentValue)... &quot;)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-嵌套函数："><a href="#6-嵌套函数：" class="headerlink" title="6.嵌套函数："></a>6.嵌套函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//嵌套函数</span><br><span class="line">func chooseStepFunction1(backward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125;</span><br><span class="line">    func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125;</span><br><span class="line">    return backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var currentValue1 = -4</span><br><span class="line">let moveNearerToZero1 = chooseStepFunction1(backward: currentValue1 &gt; 0)</span><br><span class="line">// moveNearerToZero now refers to the nested stepForward() function</span><br><span class="line">while currentValue1 != 0 &#123;</span><br><span class="line">    print(&quot;\(currentValue1)... &quot;)</span><br><span class="line">    currentValue1 = moveNearerToZero1(currentValue1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h3><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。</p>
<h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><p>sorted（by:）</p>
<h4 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// parameters 参数 可以是 in-out 参数，但不能设定默认值。可以是可变参数，元组。</span><br><span class="line">&#123;(parameters) -&gt; return type in</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//in:闭包的参数和返回值类型定义已经完成，闭包函数体即将开始</span><br><span class="line">var names2 = names.sorted(by: &#123; (s1: String, s2: String ) -&gt; Bool in return s1 &gt; s2&#125;)</span><br><span class="line">print(names2)</span><br><span class="line"></span><br><span class="line">//根据上下文推断类型</span><br><span class="line">var names3 = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2&#125;)</span><br><span class="line"></span><br><span class="line">//单表达式闭包隐式返回</span><br><span class="line">names.sorted(by: &#123;s1, s2 in s1 &gt; s2&#125;)</span><br><span class="line"></span><br><span class="line">//参数名称缩写 内联闭包 可直接通过 $0，$1，$2 来顺序调用闭包的参数</span><br><span class="line">reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</span><br><span class="line"></span><br><span class="line">//运算符方法</span><br><span class="line">names.sorted(by: &gt;)</span><br><span class="line"></span><br><span class="line">//尾随闭包</span><br><span class="line">numbers.sorted()&#123;$0 &gt; $1&#125;</span><br><span class="line">//闭包表达式是函数或方法的唯一参数</span><br><span class="line">numbers.sorted&#123;$0 &gt; $1&#125;</span><br></pre></td></tr></table></figure>
<h4 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h4><p>闭包可以在其被定义的上下文中捕获常量或变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123;</span><br><span class="line">    var runningTotal = 0</span><br><span class="line">    func incrementer() -&gt; Int &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        return runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    return incrementer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let incrementByTen = makeIncrementer(forIncrement: 10)</span><br><span class="line">let incrementByFive = makeIncrementer(forIncrement: 5)</span><br></pre></td></tr></table></figure>
<h4 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h4><p>函数和闭包都是引用类型</p>
<h4 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。</p>
<p>在参数名之前标注 @escaping。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。</p>
<p>将一个闭包标记为 @escaping 意味着你必须在闭包中显式地引用 self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//逃逸函数</span><br><span class="line">var completionHandlers: [() -&gt; Void] = []</span><br><span class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    var x = 10</span><br><span class="line">    func doSomething() &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; self.x = 100 &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x = 200 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = SomeClass()</span><br><span class="line">instance.doSomething()</span><br><span class="line">print(instance.x) </span><br><span class="line">//200</span><br><span class="line"></span><br><span class="line">completionHandlers.first?()</span><br><span class="line">print(instance.x)</span><br><span class="line">//100</span><br></pre></td></tr></table></figure>
<h4 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h4><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum CompassPoint &#123;</span><br><span class="line">    case north</span><br><span class="line">    case south</span><br><span class="line">    case east</span><br><span class="line">    case west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个枚举定义了一个全新的类型。以一个大写字母开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//directionToHead 类型初始化</span><br><span class="line">var directionToHead = CompassPoint.west</span><br><span class="line">//</span><br><span class="line">directionToHead = .east</span><br></pre></td></tr></table></figure>
<h4 id="使用-Switch-语句匹配枚举值"><a href="#使用-Switch-语句匹配枚举值" class="headerlink" title="使用 Switch 语句匹配枚举值"></a>使用 Switch 语句匹配枚举值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .south</span><br><span class="line">switch directionToHead &#123;</span><br><span class="line">    case .north:</span><br><span class="line">        print(&quot;Lots of planets have a north&quot;)</span><br><span class="line">    case .south:</span><br><span class="line">        print(&quot;Watch out for penguins&quot;)</span><br><span class="line">    case .east:</span><br><span class="line">        print(&quot;Where the sun rises&quot;)</span><br><span class="line">    case .west:</span><br><span class="line">        print(&quot;Where the skies are blue&quot;)</span><br><span class="line">    //不匹配 所有枚举成员时使用default </span><br><span class="line">    //default:</span><br><span class="line">    //  print(&quot;Not a safe place for humans&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Barcode &#123;</span><br><span class="line">    case upc(Int, Int, Int, Int)</span><br><span class="line">    case qrCode(String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var productBarcode = Barcode.upc(8, 85909, 51226, 3)</span><br><span class="line"></span><br><span class="line">productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h4><p>枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum ASCIIControlCharacter: Character &#123;</span><br><span class="line">    case tab = &quot;\t&quot;</span><br><span class="line">    case lineFeed = &quot;\n&quot;</span><br><span class="line">    case carriageReturn = &quot;\r&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="原始值的隐式赋值"><a href="#原始值的隐式赋值" class="headerlink" title="原始值的隐式赋值"></a>原始值的隐式赋值</h5><p>使用原始值为整数或者字符串类型的枚举时, Swift 将会自动为你赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Planet: Int &#123;</span><br><span class="line">    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum CompassPoint: String &#123;</span><br><span class="line">    case north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//使用枚举成员的 rawValue 属性可以访问该枚举成员的原始值</span><br><span class="line">let earthsOrder = Planet.earth.rawValue</span><br><span class="line">//earthsOrder 值为 3</span><br><span class="line"></span><br><span class="line">let sunsetDirection = CompassPoint.west.rawValue</span><br><span class="line">// sunsetDirection 值为 &quot;west&quot;</span><br></pre></td></tr></table></figure>
<h5 id="使用原始值初始化枚举实例"><a href="#使用原始值初始化枚举实例" class="headerlink" title="使用原始值初始化枚举实例"></a>使用原始值初始化枚举实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let possiblePlanet = Planet(rawValue: 7)</span><br><span class="line">// possiblePlanet 类型为 Planet? 值为 Planet.uranus</span><br></pre></td></tr></table></figure>
<h5 id="原始值构造器是一个可失败构造器"><a href="#原始值构造器是一个可失败构造器" class="headerlink" title="原始值构造器是一个可失败构造器,"></a>原始值构造器是一个可失败构造器,</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if let possiblePlanet = Planet(rawValue: 11) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h4><h3 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Resolution &#123;</span><br><span class="line">    var width = 0</span><br><span class="line">    var height = 0</span><br><span class="line">&#125;</span><br><span class="line">class VideoMode &#123;</span><br><span class="line">    var resolution = Resolution()</span><br><span class="line">    var interlaced = false</span><br><span class="line">    var frameRate = 0.0</span><br><span class="line">    var name: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someResolution = Resolution()</span><br><span class="line">let someVideoMode = VideoMode()</span><br></pre></td></tr></table></figure>
<h5 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let vga = Resolution(width: 640, height: 480)</span><br></pre></td></tr></table></figure>
<h5 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let hd = Resolution(width: 1920, height: 1080)</span><br><span class="line">var cinema = hd</span><br><span class="line"></span><br><span class="line">cinema.width = 2048</span><br><span class="line"></span><br><span class="line">print(&quot;cinema is now  \(cinema.width) pixels wide&quot;)</span><br><span class="line">// 打印 &quot;cinema is now 2048 pixels wide&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;hd is still \(hd.width) pixels wide&quot;)</span><br><span class="line">// 打印 &quot;hd is still 1920 pixels wide&quot;</span><br></pre></td></tr></table></figure>
<h5 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h5><h5 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h5><ul>
<li>等价于（===）</li>
<li>不等价于（!==）</li>
</ul>
<p><strong><em>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例</em>。</strong></p>
<p><strong><em>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</em></strong></p>
<h5 id="字符串、数组、和字典类型的赋值与复制行为"><a href="#字符串、数组、和字典类型的赋值与复制行为" class="headerlink" title="字符串、数组、和字典类型的赋值与复制行为"></a>字符串、数组、和字典类型的赋值与复制行为</h5><p>Swift 中，许多基本类型，诸如 String，Array 和 Dictionary 类型均以结构体的形式实现.</p>
<p>Objective-C 中 NSString，NSArray 和 NSDictionary 类型均以类的形式实现，而并非结构体。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct FixedLengthRange &#123;</span><br><span class="line">    var firstValue: Int</span><br><span class="line">    let length: Int</span><br><span class="line">&#125;</span><br><span class="line">var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)</span><br><span class="line">// 该区间表示整数0，1，2</span><br><span class="line">rangeOfThreeItems.firstValue = 6</span><br><span class="line">// 该区间现在表示整数6，7，8</span><br></pre></td></tr></table></figure>
<h5 id="常量结构体的存储属性"><a href="#常量结构体的存储属性" class="headerlink" title="常量结构体的存储属性"></a>常量结构体的存储属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)</span><br><span class="line">// 该区间表示整数0，1，2，3</span><br><span class="line">rangeOfFourItems.firstValue = 6</span><br><span class="line">// 尽管 firstValue 是个变量属性，这里还是会报错</span><br></pre></td></tr></table></figure>
<p>由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>
<p>属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。</p>
<h5 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h5><p>指当第一次被调用的时候才会计算其初始值的属性。</p>
<p>在属性声明前使用 ==lazy== 来标示一个延迟存储属性。</p>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct AlternativeRect &#123;</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + (size.width / 2)</span><br><span class="line">            let centerY = origin.y + (size.height / 2)</span><br><span class="line">            return Point(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            origin.x = newValue.x - (size.width / 2)</span><br><span class="line">            origin.y = newValue.y - (size.height / 2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="简化-Setter-声明"><a href="#简化-Setter-声明" class="headerlink" title="简化 Setter 声明"></a>简化 Setter 声明</h5><p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue。</p>
<h5 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h5><p>只有getter，可以去掉 get 关键字和花括号</p>
<h4 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h4><ul>
<li><p>属性观察者会观察并对属性值的变化做出回应。</p>
</li>
<li><p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器.</p>
</li>
<li><p>也可以通过在子类里重写属性来为任何继承属性（无论是存储属性还是计算属性）添加属性观察者</p>
</li>
</ul>
<p>可以为属性添加如下的一个或全部观察器：</p>
<p>==willSet== 会在该值被存储之前被调用。</p>
<ul>
<li>实现了一个 willSet 观察者，新的属性值会以常量形式参数传递。</li>
<li>可以在 willSet 实现中为这个参数定义名字。如果没有为它命名，那么它会使用默认的名字 newValue</li>
</ul>
<p>==didSet== 会在一个新值被存储后被调用。</p>
<ul>
<li>实现了一个 didSet观察者，一个包含旧属性值的常量形式参数将会被传递。</li>
<li>可以为它命名，也可以使用默认的形式参数名 oldValue 。</li>
<li>如果在属性自己的 didSet 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class StepCounter &#123;</span><br><span class="line">    var totalSteps: Int = 0 &#123;</span><br><span class="line">        willSet(newTotalSteps) &#123;</span><br><span class="line">            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            if totalSteps &gt; oldValue  &#123;</span><br><span class="line">                totalSteps += oldTotalSteps</span><br><span class="line">                print(&quot;Added \(totalSteps - oldValue) steps&quot;)</span><br><span class="line">                print(&quot;totalSteps: \(totalSteps) steps&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let stepCounter = StepCounter()</span><br><span class="line">stepCounter.totalSteps = 200</span><br><span class="line">// About to set totalSteps to 200</span><br><span class="line">// Added 200 steps</span><br><span class="line">stepCounter.totalSteps = 360</span><br><span class="line">// About to set totalSteps to 360</span><br><span class="line">// Added 160 steps</span><br><span class="line">stepCounter.totalSteps = 896</span><br><span class="line">// About to set totalSteps to 896</span><br><span class="line">// Added 536 steps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。</p>
</blockquote>
<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。</p>
<p>全局变量是在函数、方法、闭包或任何类型之外定义的变量。</p>
<p>局部变量是在函数、方法或闭包内部定义的变量。</p>
<p>全局或局部变量都属于存储型变量.</p>
<blockquote>
<p>注意 : 全局的常量或变量都是延迟计算</p>
</blockquote>
<h4 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h4><ul>
<li>无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性</li>
<li>类似 static 静态变量<blockquote>
<p>注意:<br>实例的存储型属性不同，必须给存储型类型属性指定默认值.<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。不需要lazy</p>
</blockquote>
</li>
</ul>
<h5 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure &#123;</span><br><span class="line">    static var storedTypeProperty = &quot;Some value.&quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">enum SomeEnumeration &#123;</span><br><span class="line">    static var storedTypeProperty = &quot;Some value.&quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        return 6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    static var storedTypeProperty = &quot;Some value.&quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">        return 27</span><br><span class="line">    &#125;</span><br><span class="line">    class var overrideableComputedTypeProperty: Int &#123;</span><br><span class="line">        return 107</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取和设置类型属性的值"><a href="#获取和设置类型属性的值" class="headerlink" title="获取和设置类型属性的值"></a>获取和设置类型属性的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(SomeStructure.storedTypeProperty)</span><br><span class="line">// 打印 &quot;Some value.&quot;</span><br><span class="line">SomeStructure.storedTypeProperty = &quot;Another value.&quot;</span><br><span class="line">print(SomeStructure.storedTypeProperty)</span><br></pre></td></tr></table></figure>

      
    </div>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/09/11/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
  <br>
</article>




</div>
<div class="col-md-3 col-sm-3 blog-sidebar">
  <!-- CATEGORIES START -->
<h2 class="no-top-space">Categories</h2>


<!-- CATEGORIES END -->

<!-- BEGIN BLOG TAGS -->
<div class="blog-tags margin-bottom-20">
  <h2>Tags</h2>
  

</div>
<!-- END BLOG TAGS -->


<!-- BEGIN FEATURED POSTS -->                            
<h2>Featured Posts</h2>
<div class="recent-news margin-bottom-10">
  
    
  
    
  
</div>
<!-- END FEATURED POSTS -->                            

</div>
</div>

  </section>
</div>

    <!-- BEGIN PRE-FOOTER -->
    <div class="pre-footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN BOTTOM ABOUT BLOCK -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>About Us</h2>
            <p></p>
          </div>
          <!-- END BOTTOM ABOUT BLOCK -->

          <!-- BEGIN BOTTOM CONTACTS -->
          <div class="col-md-4 col-sm-6 pre-footer-col">
            <h2>Contact</h2>
            <address class="margin-bottom-40">
              <br>
              <br>
              <br>
              Phone: <br>
              Email: <a href="mailto:"></a><br>
            </address>
          </div>
          <!-- END BOTTOM CONTACTS -->

	
        </div>
      </div>
    </div>
    <!-- END PRE-FOOTER -->

    <!-- BEGIN FOOTER -->
    <div class="footer">
      <div class="container">
        <div class="row">
          <!-- BEGIN COPYRIGHT -->
          <div class="col-md-6 col-sm-6 padding-top-10">
                  &copy; 2018 Hexo<br>
 <a href="javascript:;">Privacy Policy</a> | <a href="javascript:;">Terms of Service</a>
          </div>
          <!-- END COPYRIGHT -->
	  <!-- BEGIN SOCIAL -->
<div class="col-md-6 col-sm-6">
  <ul class="social-footer list-unstyled list-inline pull-right">
    
  </ul>  
</div>
<!-- END SOCIAL -->

        </div>
      </div>
    </div>
    <!-- END FOOTER -->

  <!-- BEGIN CORE PLUGINS (REQUIRED FOR ALL PAGES) -->
<!--[if lt IE 9]>
<script src="/metronic/assets/plugins/respond.min.js"></script>
<![endif]--> 
<script src="/metronic/assets/plugins/jquery.min.js"></script>
<script src="/metronic/assets/plugins/jquery-migrate.min.js"></script>
<script src="/metronic/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script src="/metronic/assets/corporate/scripts/back-to-top.js"></script>
<script src="/metronic/assets/plugins/owl.carousel/owl.carousel.min.js"></script>
<script src="/metronic/assets/corporate/scripts/layout.js"></script>
<script src="/js/wow.min.js"></script>



<script type="text/javascript">
    jQuery(document).ready(function() {
        Layout.init();    
        Layout.initOWL();
        Layout.initTwitter();
        Layout.initFixHeaderWithPreHeader(); /* Switch On Header Fixing (only if you have pre-header) */
        Layout.initNavScrolling(); 
	new WOW().init();
    });
</script>
<!-- END CORE PLUGINS -->

<!-- BEGIN PAGE-SPECIFIC PLUGINS --> 







<!-- END PAGE-SPECIFIC PLUGINS --> 

<!-- BEGIN INTEGRATIONS -->





<!-- END INTEGRATIONS -->

</body>
</html>
